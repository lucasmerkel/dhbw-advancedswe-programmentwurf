\chapter{Unit Tests}
\label{unit-tests}
Während eines Entwicklungsprozesses einer Software entstehen Fehler.
Fehler kosten jedoch unterschiedliche Ressourcen und steigen mit der Zeit, seit der Fehler existiert.
Daher sind Tests ein wichtiges Mittel in der Softwareentwicklung.

Hierfür gibt es folgende Testklassifikationen:
\begin{itemize}
    \item \textit{Akzeptanztests},
    \item \textit{Integrationstests},
    \item \textit{Komponententests} sowie
    \item \textit{Leistungstests}.
\end{itemize}

In diesem Softwareentwurf werden ausschließlich \textit{Unit Tests} betrachtet.
\textit{Unit Tests} zählen zu den \textit{Komponententests} und starten nur den relevanten Teil des Systems.
Weitere nötige Systemteile werden durch Stellvertreter, sogenannten \textit{Mock-Ups}, ersetzt.
\textit{Mock-Ups} sind einfache Stellvertreter, in Form einer Minimalumsetzung der zum Testen nötigen Funktionalität, für in der späteren Laufzeit der Umgebung \glqq echte\grqq{} Objekte.
Die Umsetzung der Funktionalitäten wird auch als \textit{Fakes} bezeichnet.
Der Vorteil durch den Einsatz von \textit{Mock-Ups} ist, dass Abhängigkeiten während eines Tests ersetzt werden können und somit eine isolierte Betrachtung der Klassen möglich ist.
Die Durchführung findet mittels Testframeworks, wie beispielsweise im Java-Umfeld JUnit, statt.
\textit{Unit Tests} haben das Ziel, die korrekte Implementierung der Komponente sicherzustellen.

Der Aufbau eines Unit-Tests orientiert sich an der AAA-Regel und steht für:
\begin{itemize}
    \item \textit{Arrange},
    \item \textit{Act} und
    \item \textit{Assert}.
\end{itemize}

\textit{Arrange} bezeichnet das Initialisieren der Test-Umgebung.
\textit{Act} beschreibt den Teil, der für das Ausführen der zu testenden Applikation nötig ist.
\textit{Assert} bezeichnet den Teil, der für das Prüfen der Test-Zusicherung nötig ist.

Mögliche Testergebnisse können wie folgt sein:
\begin{itemize}
    \item \textit{Success},
    \item \textit{Failure} und
    \item \textit{Error}.
\end{itemize}

\textit{Success} bedeutet, dass die Testmethode durchläuft und alle Assertions erfüllt sind.
\textit{Failure} bedeutet, dass der Test aufgrund einer oder mehrerer Assertions nicht bestanden wurde.
\textit{Error} bedeutet, dass der Test aufgrund eines Fehlers nicht bestanden wurde.

\section{ATRIP}
Bei \textit{Unit Tests} orientiert man sich zudem an den folgenden \textit{ATRIP-Regeln}:
\begin{itemize}
    \item \textit{Automatic},
    \item \textit{Thorough},
    \item \textit{Repeatable},
    \item \textit{Independent} und
    \item \textit{Professional}.
\end{itemize}

\textit{Automatic} bedeutet, dass die Tests selbstständig ablaufen und Ergebnisse selbst prüfen müssen.
\textit{Thorough} besagt, dass gute Tests alle missionskritischen Funktionalitäten testet.
\textit{Repeatable} legt fest, dass ein Test jederzeit durchführbar sein soll und immer das gleiche Ergebnis liefert.
\textit{Independent} bedeutet, dass jeder Test genau ein Aspekt der Komponente testet.
Somit müssen die Tests gewährleisten, dass sie in beliebiger Zusammenstellung und Reihenfolge funktionsfähig sind.
\textit{Professional} besagt, dass Testcode auch produktionsrelevanter Code ist und somit leicht verständlich sein sollte.

\section{Testabdeckung}
Eine Möglichkeit zur Messung der Testabdeckung ist die \textit{Code Coverage}.
Eine Variante ist das Messen der \textit{Line Coverage}, indem die Anzahl der abgedeckten Code-Zeilen bestimmt wird.
Eine weitere Variante ist das Messen der \textit{Branch Coverage}, indem die Anzahl der abgedeckten Pfade im Code bestimmt werden.

\section{Testen mit Mocks}
Das Testen mit Mocks erweitert die AAA-Regel beim Durchführen von \textit{Unit Tests}.
Der Test wird zu Beginn um die Phasen \textit{Capture} und am Ende um \textit{Verify} erweitert.
In \textit{Capture} wird der Mock Initialisiert, dann folgen die bekannten Regeln \textit{Arrange}, \textit{Act} und \textit{Assert} aus den Unit-Tests und am Ende wird in \textit{Verify} die Erwartungen überprüft.
Weitere Voraussetzungen für das Testen mit Mocks ist, dass ein Einsatz nur sinnvoll ist, wenn eine Dependency Injection möglich ist.
Des Weiteren sind statische Methoden und vergleichbare Konstrukte schwierig zu ersetzen.
Zudem sind tiefe Abhängigkeitsstrukturen nur aufwendig nachzubilden.
Hierbei sollte sich bei der Entwicklung an das \textit{Law of Demeter} gehalten werden.

\section{Anwendung im Softwareentwurf}
Bei den Unit-Tests wurde ein besonderer Fokus auf die Validierungs-Klassen in der \textit{Abstraktions}-Schicht sowie das Erzeugen und Ändern einzelner Attribute eines \href{}{\code{}}\code{ConsumerGoods} gelegt.
Die Testklassen sind innerhalb des Projekts \textit{0-cleanproject-plugins} im Verzeichnis \textit{src.test.java} gelistet.
Bei der Erstellung der Tests wurde eine Einteilung entsprechend \href{}{\textit{Arrange}}, \href{}{\textit{Act}} sowie \href{}{\textit{Assert}} vorgenommen.
Die Testklasse \href{}{\code{}}\code{DayDateTest} überprüft die Funktionalität der Klasse \href{}{\code{}}\code{DayValidator}, indem eine Validierung eines gültigen als auch eines negativen oder eines über 31 liegenden Wertes gestestet wird.
Die Testklasse \href{}{\code{}}\code{MonthDateTest} überprüft die Funktion der Klasse \href{}{\code{}}\code{MonthValidator}, indem eine Validierung eines gültigen als auch eines negativen oder eines über 12 liegenden Wertes gestestet wird.
Die Testklasse \href{}{\code{}}\code{YearDateTest} überprüft die Funktion der Klasse \href{}{\code{}}\code{YearValidator}, indem eine Validierung eines gültigen als auch eines negativen Wertes gestestet wird.
Die Testklasse \href{}{\code{}}\code{DateValidatorTest} überprüft die Funktion der Klasse \code{DateValidator}, indem eine Validierung eines gültigen als auch eines ungültigen Datums im Februar und an einem Monat mit 30 statt 31 Tagen gestestet wird.
Die Test liegen sehr nahe beieinander, jedoch wurde eine Aufteilung aufgrund der Verständlichkeit (entsprechend der \textit{Professional}-Regel) vorgenommen.
Die Testklasse \href{}{\code{}}\code{UnitOfMeasureValueTest} überprüft die Funktion der Klasse \href{}{\code{}}\code{ValueValidator}, indem eine Validierung eines gültigen als auch eines negativen Wertes gestestet wird.

Die Testklasse \href{}{\code{}}\code{StoreConsumerGoodsTest} überprüft die Klasse \href{}{\code{}}\code{ConsumerGoodsBuilder} sowie dessen Validierungsmethode, indem unterschiedliche Kombinationen mit invaliden Übergabeparametern getestet werden.

Die Testklasse \href{}{\code{}}\code{ConsumerGoodsGuiControllerTest} dient der Überprüfung der \href{}{\code{}}\ac{HTTP}-Statuscodes für erfolgreiche als auch fehlerhafte Anfragen zum Erhalt, der Erzeugung dem Aktualisieren oder Löschen von ConsumerGoods.

Der Schwerpunkt der genannten Klassen, mit Ausnahme von \href{}{\code{}}\code{ConsumerGoodsGuiControllerTest}, liegt auf der Wertevalidierung als Grundlage zur Vermeidung von auftretenden Fehlern, die zu einem Fehlverhalten der Software führen können, das unter Umständen nicht direkt bemerkt wird oder auch durch den Tausch verschiedener Peripherie auftreten könnte.
Neben der \textit{Professional}-Regel wurde auf die weiteren ATRIP-Regeln geachtet.
\begin{itemize}
    \item Die Tests laufen selbstständig und überprüfen ihr Ergebnis selbst (\textit{Automatic}),
    \item als Aufgabe des Verwaltens von Konsumgüter testen Sie die Grundlage der ordnungsgemäßen Werteverwaltung der Konsumgüter(\textit{Thorough}),
    \item die Tests sind jederzeit durchführbar und das Ergebnis reproduzierbar (\textit{Repeatable}),
    \item die Tests sind unabhängig zueinander und testen jeweils eine Komponente \textit{Independent}.
\end{itemize}

Als Beispiel für die Erfüllung der \textit{Automic}-Regel dient das Nutzen von Assertions wie in \href{}{\code{}}\code{DateValidatorTest} zu erkennen.
Dieses Mittel wurde auch bei den anderen Tests angewandt, indem das erwartete Ergebnis fest im \textit{Assert}-Teil des Tests programmiert ist und der Test daraufhin die Erfüllung selbst überprüft.
Es werden auch keine Informationen zur Laufzeit über den Nutzer abgefragt, um die \textit{Atomic}-Regel zu erfüllen.
Die \textit{Thorough}-Regel wurde insofern eingehalten, dass der Schwerpunkt der Tests auf den Validierungsklassen, wie dem \href{}{\code{}}\code{DateValidatorTest} oder dem \href{}{\code{}}\code{UnitOfMeasureValueTest} gelegt wurde.
Gleiches gilt für \href{}{\code{}}\code{StoreConsumerGoodsTest}, indem der Schwerpunkt auf die Validierung der Attribute zum Erzeugen eines Konsumguts liegt.
Dadurch können Fehler, die aufgrund ungültiger Wertangaben, wie zum Beispiel negativen Werten oder einem falschen Datum auftreten können und für Bugs oder darauf aufbauenden Fehlern führen können, vermieden werden.
Ein weiteres Beispiel für das Einhalten der \textit{Repeatable}-Regel ist ebenfalls im \textit{Arrange}-Teil des Tests \href{}{\code{}}\code{DateValidatorTest} dargestellt.
Zur Erfüllung dieser Regel wurden zu prüfende Daten statisch festgelegt und werden nicht zur Laufzeit, wie beispielsweise die Wahl des aktuellen Datum, bestimmt.
Die \textit{Independent}-Regel wurde eingehalten. Dazu wurde darauf geachtet, dass jede Testklasse nur eine Komponente testet.
Das wurde erfüllt, indem jede Testklasse eine der implementierten Validierungsklassen testet.
Durch die Entkopplung zueinander können die Tests unabhängig und in beliebiger Reihenfolge ausgeführt werden.
Alle nötigen Informationen zum unabhängigen Durchführen des Tests sind im \textit{Assert}-Teil des Tests definiert, wie in \href{}{\code{}}\code{DateValidatorTest} beispielhaft dargestellt.
Zur Erfüllung der \textit{Professional}-Regel wurde sich an der \textit{Ubiquitous Language} aus \ac{DDD} orientiert. Ein Beispiel hierzu ist die Bezeichnung der Testklassen, indem domänenspezifische Titel wie \href{}{\code{}}\textit{DateValidationTest} oder \href{}{\code{}}\textit{UnitOfMeasureValueValidationTest} genutzt wurden.
Bei den Testmethoden wurde ebenfalls eine klare Bezeichnung gewählt, die das darauf folgende Testergebnis verständlich macht.
Ein Beispiel hierfür ist in \href{}{\code{}}\textit{DateValidationTest}, indem die Methoden wie beispielsweise \href{}{\code{}}\textit{ checkValidatorForInvalideFebruaryDate()} oder \href{}{\code{}}\textit{ checkValidatorForFebruaryDateInLeapYear()} den gezielten Test beschreiben.

\subsection*{Unit-Tests mit Einsatz von Mocks}
Zuzüglich zu den erläuterten Unit Tests testet die Testklasse \href{}{\code{}}\code{UpdateConsumerGoodsTest} das Ändern von Attributen einer Instanz der Klasse \href{}{\code{}}\code{ConsumerGoods} mit Hilfe eines Mocking-Werkzeugs.
Der Test bildet den Ablauf der Methode \href{}{\code{}}\code{updateConsumerGoods()} in der Klasse \href{}{\code{}}\code{ConsumerGoodsManager} ab.
Dabei wird eine im Test erzeugte Instanz der Klasse \href{}{\code{}}\code{ConsumerGoods} mit den Attributen eines neuen, im Test gemockten, Objekts der Klasse \href{}{\code{}}\code{ConsumerGoods} aktualisiert.

Darüber hinaus wird in der bereits erläuterten Testklasse \href{}{\code{ConsumerGoodsGuiControllerTest}} innerhalb der Testmethode \href{}{\code{deleteFailureTest()}} ebenfalls ein Mock zur Simulation der Reaktion des \href{}{\code{ConsumerGoodsRepository}} erzeugt.

Zu einem älteren Entwicklungsstand wurde in der Testklasse \href{}{\code{}}\code{StoreConsumerGoodsTest} ebenfalls Mocks zum Testen angewandt, da die Überprüfung des \ac{EAN}-Codes zu dem Zeitpunkt in \href{}{\code{}}\code{ConsumerGoodsBuilder} stattfand und somit ein eine Instanz des \href{}{\code{}}\code{ConsumerGoodsRepository} übergeben werden musste.

Auch die Unit-Tests mit dem Einsatz von Mocks erfüllen die \textit{ATRIP}-Regeln und erzielen das Testergebnis \textit{Success}.

Als Beispiel für die Erfüllung der \textit{Automic}-Regel dient ebenfalls der Einsatz von Assertions und das statische Programmieren von Ergebnissen, wie in \href{}{\code{}}\code{UpdateConsumerGoodsTest} dargestellt.
Auch bei diesen Tests werden alle Informationen im \textit{Arange}-Teil des Tests hinterlegt und somit keine Abfragen während der Laufzeit des Tests abgefragt.
Die \textit{Thorough}-Regel wurde an diesem Beispiel eingehalten, indem die Tests die Grundfunktionalitäten der Anwendung, wie durch den Test \href{}{\code{}}\code{UpdateConsumerGoodsTest} das Aktualisieren eines Konsumguts, mit \href{}{\code{}}\code{StoreConsumerGoodsTest} das Einlagern eines Konsumguts und mit \href{}{\code{}}\code{ConsumerGoodsGuiControllerTest} die Interaktionsschnittstelle zur \ac{GUI} testen.
Ein weiteres Beispiel für das Einhalten der \textit{Repeatable}-Regel ist ebenfalls im \textit{Arrange}-Teil des Tests \href{}{\code{}}\code{ConsumerGoodsGuiControllerTest} dargestellt.
Zur Erfüllung dieser Regel wurden zu prüfende Daten statisch festgelegt und werden nicht zur Laufzeit, wie beispielsweise die Wahl die Zusammenstellung der \ac{URI} zur Kommunikation mit der Schnittstelle über \ac{HTTP}, bestimmt.
Die \textit{Independent}-Regel wurde eingehalten.
Es wurde darauf geachtet, dass jede Testklasse ebenfalls nur eine Komponente testet.
Ein Beispiel ist die Testklasse \href{}{\code{}}\code{StoreConsumerGoodsTest}, welche die Validierung der Attribute zum Anlegen eines Konsumguts testet.
Durch die Entkopplung zueinander können die Tests ebenfalls unabhängig und in beliebiger Reihenfolge ausgeführt werden.
Alle nötigen Informationen zum unabhängigen Durchführen des Tests sind im \textit{Assert}-Teil des Tests definiert, wie in \href{}{\code{}}\code{ConsumerGoodsGuiControllerTest} beispielhaft dargestellt.
Zur Erfüllung der \textit{Professional}-Regel wurde sich an der \textit{Ubiquitous Language} aus \ac{DDD} orientiert. Ein Beispiel hierzu ist die Bezeichnung der Testklassen, indem anstatt der technischen Begriffe \textit{AddConsumerGood} domänenspezifische Titel wie \textit{StoreConsumerGoods} genutzt wurden.
Bei den Testmethoden wurde ebenfalls eine klare Bezeichnung gewählt, die das darauf folgende Testergebnis verständlich macht.
Ein Beispiel hierzu findet sich in \href{}{\code{}}\code{StoreConsumerGoodsTest}, indem die Methoden \href{}{\code{}}\textit{ checkStoreValidConsumerGood()} oder \href{}{\code{}}\textit{ checkStoreConsumerGoodWithoutFoodDescription()} die domänenspezifische Bezeichnung verwenden und somit für Domänenexperten verständlich wird, was der Test überprüft, ohne den Testablauf im Detail zu verstehen.

\subsection*{Code Coverage}
Die Code Coverage-Ergebnisse nach Durchführen der Unit-Tests sind in Tabelle \ref{tab:code-coverage-full} dargestellt.
Bei Betrachtung der Testabdeckung ist zu erkennen, dass der Schwerpunkt der Tests auf den Klassen in der \textit{Domain}- sowie in der \textit{Abstraction}-Schicht auf den Validierungsklassen sowie der Erzeugung eines Konsumguts durch den \href{}{\code{}}\code{ConsumerGoodsBuilder} befindet.
Das ist entspricht auch den Testbereichen der Testklassen \href{}{\code{}}\code{DateValidatorTest}, \href{}{\code{}}\code{DayDateTest}, \href{}{\code{}}\code{MonthDateTest}, \href{}{\code{}}\code{YearDateTest} sowie \href{}{\code{}}\code{UnitOfMeasureValueTest}, die den dazugehörigen Validator testen.

Die Code Coverage verdeutlicht, dass der Fokus auf die Validierungsklassen im Package \textbf{de.dhbw.cip.domain} sowie den dazugehörigen domänenspezifischen Klassen in dem sowie im Package \textbf{de.dhbw.cip.abstractioncode} liegt. 
Hinzu kommt das Testen der Attributvalidierung des \href{}{\code{}}\code{ConsumerGoodsBuilder}.
Da eine Persistierung noch nicht vorgesehen ist, sind die Klassen im Package \textbf{de.dhbw.cip.application} ebenfalls noch nicht in Tests berücksichtigt.
Eine Ausnahme stellt die Testklasse \href{}{\code{}}\code{ConsumerGoodsGuiControllerTest}, diese überprüft die \ac{HTTP}-Schnittstelle und die entsprechenden Rückmeldungen des Servers an die GUI. 
Hierzu muss der Service jedoch in Betrieb sein und somit ist zu beachten, dass die die getestete Code Coverage nicht zur Testinstanz zählt.
Gleiches gilt für die Klassen im Package \textbf{de.dhbw.cip.adapters}, schließlich handelt es sich hierbei um Klassen zum Trennen der inneren domänenspezifischen Klassen in äußere, für die Schnittstellen relevante Klassen.

\begin{table}[ht]
    \begin{tabular}{|l|c|}
        \hline
        \textbf{Paket-/Klassenname} & \textbf{Code Coverage} \\
        \hline
        \textbf{de.dhbw.cip} & 0.0\% \\
        \hline
        ConsumerInventoryPlannerApplication & 0.0\% \\
        \hline
        \textbf{de.dhbw.cip.plugin.rest} & 0.0\% \\
        \hline
        ConsumerGoodsGuiController & 0.0\% \\
        \hline
        StorageGuiController & 0.0\% \\
        \hline
        \textbf{de.dhbw.cip.plugins.persistence.hibernate} & 0.0\% \\
        \hline
        ConsumerGoodsRepositoryBridge & 0.0\% \\
        \hline
        FridgeRepositoryBridge & 0.0\% \\
        \hline
        FoodShelfRepositoryBridge & 0.0\% \\
        \hline
        PersistenceConsumerGoodsRepository & 0.0\% \\
        \hline
        PersistenceFridgeRepository & 0.0\% \\
        \hline
        PersistenceFoodShelfRepository & 0.0\% \\
        \hline
        \textbf{de.dhbw.cip.adapters} & 0.0\% \\
        \hline
        ConsumerGoodsToConsumerGoodsResourceMapper.java & 0.0\% \\
        \hline
        ConsumerGoodsResource.java & 0.0\% \\
        \hline
        BestBeforeDateResource.java & 0.0\% \\
        \hline
        FoodResource.java & 0.0\% \\
        \hline
        FoodShelfToFoodShelfResourceMapper.java & 0.0\% \\
        \hline
        FridgeToFridgeResourceMapper.java & 0.0\% \\
        \hline
        StorageResource.java & 0.0\% \\
        \hline
        FoodShelfResource.java & 0.0\% \\
        \hline
        FridgeResource.java & 0.0\% \\
        \hline
        \textbf{de.dhbw.cip.application} & 0.0\% \\
        \hline
        ConsumerGoodsManager.java & 0.0\% \\
        \hline
        StorageManager.java & 0.0\% \\
        \hline
        \textbf{de.dhbw.cip.domain} & 63.5\% \\
        \hline
        ConsumerGoods.java & 68.3\% \\
        \hline
        BestBeforeDate.java & 48.8\% \\
        \hline
        Food.java & 36.6\% \\
        \hline
        Storage.java & 46.2\% \\
        \hline
        FoodShelf.java & 0.0\% \\
        \hline
        Fridge.java & 50.0\% \\
        \hline
        DateValidator.java & 71.4\% \\
        \hline
        DayValidator.java & 75.0\% \\
        \hline
        MonthValidator.java & 75.0\% \\
        \hline
        ValueValidator.java & 66.7\% \\
        \hline
        YearValidator.java & 66.7\% \\
        \hline
        \textbf{de.dhbw.cip.abstractioncode} & 57.4\% \\
        \hline
        DayOfYear.java & 53.1\% \\
        \hline
        Volume.java & 50.0\% \\
        \hline
        Weight.java & 50.0\% \\
        \hline
        DayOfYear.java & 53.1\% \\
        \hline
        Quantity.java & 61.5\% \\
        \hline
        Day.java & 60.0\% \\
        \hline
        Month.java & 60.0\% \\
        \hline
        Value.java & 60.0\% \\
        \hline
        Year.java & 60.0\% \\
        \hline
        UnitOfMeasure.java & 100.0\% \\
        \hline
    \end{tabular}
    \caption{Code Coverage des gesamten Projekts.}
    \label{tab:code-coverage-full}
\end{table}

\chapter{Programming Principles}
Im Folgenden Kapitel werden die \textit{Programming Principles} erläutert und in Bezug auf den Programmentwurf analysiert sowie Umsetzungen begründet.

\section{Zu betrachtende Programming Principles}
Programming Principles dienen als Prinzipien in der Softwareentwicklung.
Dementsprechend sind Programming Principles als allgemein anerkannte Regeln zur Begründung und Argumentation von Umsetzungen zu verstehen.
Sie entsprechen somit Grundlage für Entscheidungen und betrachten dabei das gesamte Softwareprojekt.
Die Programming Principles sind dabei eine kontextlose Idealvorstellung und haben die Funktion als Leitlinien für zielgerichtetetes Handeln.
Das hat zur Folge, dass kontextabhängig gewisse Abweichungen nötig sein können.
Daher gilt es, neben dem Anwenden der Prinzipien auch mögliche Abweichungen zu begründen.
Gleichzeitig können sich die jeweiligen Prinzipien gegeneinander widersprechen.
Hierbei ist es nötig, kontextabhängig entsprechend abzuwirken und die Entscheidung ebenfalls zu begründen.

Zu den betrachteten Programming Principles zählt SOLID.
SOLID setzt sich aus den Prinzipien
\begin{itemize}
    \item \textit{Single Responsibility Principle} (SRP),
    \item \textit{Open/Closed Principle} (OCP),
    \item \textit{Liskov Substitution Principle} (LSP),
    \item \textit{Interface Segregation Principle} (ISP),
    \item \textit{Dependency Inversion Principle} (DIP)
  \end{itemize}
zusammen.
Die SOLID-Regeln haben das Ziel, unter Anwendung der Regeln wartbare sowie erweiterbare Systeme sowie eine langlebige Codebasis zu schaffen.

Um dies zu gewährleisten, beschreibt die erste Regel, das \textit{Single Responsibility Principle}, das Prinzip der einzigen Zuständigkeit.
Die Regel besagt, dass eine Klasse nur einen zeinigen Grund haben sollte, sich zu ändern.
Eine Klasse sollte somit nur eine Verantwortlichkeit haben.
Ein Objekt der Klasse hat somit eine klar definierte Aufgabe und übergeordnetes Verhalten wird durch das Zusammenspiel mehrerer Klassen ermöglicht.
Damit soll vermieden werden, dass es zu einer Überdeckung des Sourcecodes bezogen auf dessen Anwendung für die Zuständigkeit kommt.
Dieses Problem bezeichnet man als Feature Drift.
Eine Änderung an diesem Sourcecode, der für mehrere Zuständigkeiten genutzt wird, hätte zur Folge, dass ungewollt eine anderweitige Zuständigkeit der Klasse verändert wird.
Das Problem kann auch visuell mittels eines Koordinatensystems dargestellt werden.
Jede Achse beschreibt eine Zuständigkeit.
Änderungen entlang der Achse führen zu Codeanpassungen.
Im Optimalfall beeinflussen sich die Zuständigkeit nicht gegenseitig.
Somit würde die Änderung des gemeinsamen Punktes auf der entsprechenden Zuständigkeitsachse zu keinen Änderungen auf den anderen Achsen und somit auch zu keiner Änderung des Codes der anderen Zuständigkeiten führen.
Dieser Fall ist jedoch in der Realität selten anzutreffen.
Unter Anwendung der Regel resultiert eine niedrigere Kopplung und Komplexität des Codes.
Mehrere Verantwortlichkeiten beziehungsweise die Zuständigkeit einer Klasse sollte dabei zu erkennen sein.

Eine weitere Regel ist das \textit{Open/Closed Principle}.
Diese Regel besagt, dass Software-Entitäten, wie beispielsweise Klassen oder Methoden, offen für Erweiterungen aber zeitgleich geschlossen für Veränderungen sein sollen.
Zu Veränderungen zählen hierbei Codemodifikationen aufgrund geänderter Anforderungen.
Bestehender Code sollte dabei nicht geändert werden müssen und angepasste Anforderungen führen somit nur zu einer Erweiterung des Codes.
Eine mögliche Erweiterung kann dabei eine Vererbung darstellen.
Die Klasse wird somit durch die Unterklasse erweitert, zeitlgeich findet in der Klasse keine Veränderung statt.
Dabei ist auch hier zu erkennen, dass kein Programm komplett immun gegen Modifikationen sein kann.
Der Entwickler kann jedoch bestimmen, welche Änderungen durch Erweiterungen ermöglicht werden.
Hierfür ist jedoch eine Erfahrung in der Domäne und der Umsetzung nötig.
Das \textit{Open/Closed Principle} ist ein wichtiges Werkzeug, dass es zu kennen gilt, jedoch sollte es kein beherrschendes Designziel sein, da es sonst zu einer spekulativer Komplexität führen kann.

Die dritte Regel ist das \textit{Liskov Substitution Principle}.
Diese Regel legt fest, dass Objekte in einem Programm durch Instanzen ihrer Subtypen ersetzbar sein sollten, ohne die Korrektheit des Programms zu ändern.
Die Regel gibt somit strikte Regeln für Vererbungshierachien vor und befasst sich daher mit den Varianzregeln.
Varianzregeln beschreiben die Ersetzbarkeit eines Objekts durch ein Objekt der Ober- oder Unterklasse.
Es gibt dabei drei Arten:
Kovarianz besagt, dass die Typhierachie und die Vererbungshierachie die gleiche Richtung haben.
In der Programmiersprache Java wird Kovarianz präferiert.
Kontravarianz beschreibt, dass die Typhierachie entgegengesetzt zur Vererbungshierachie ist.
Invarianz bedeutet, dass die Typhierachie unverändert bleibt.
Zur Umsetzung des \textit{Liskov Substitution Principle} müssen sich daher Subtypen so verhalten wie ihr Basistyp.
Ein Subtyp darf dabei die Funktionalität erweitern, jedoch nicht einschränken.
Hierbei zeigen sich Parallelen zum \textit{Open/Closed Principle}.
Somit ist das \textit{Liskov Substitution Principle} erfüllt, wenn man jede Spezialisierung einer Generalisierung überall dort einsetzen kann, an den Stellen die Generalisierung verwendet wird.

Eine weitere Regel des SOLIP Prinzips ist das \textit{Interface Segregation Principle}.
Diese Regel besagt, dass mehrere spezifische Interface besser sind als ein Allround-Interface.
Interface sollen Klient-spezifisch sein.
Daraus resultiert eine höhere Kohäsion und somit repräsentieren Klassen oder Interfaces eine Einheit sehr genau.
Die Regel unterstützt somit die erste Regel, das \textit{Single Responsibility Principl}.
Ein Klient soll dabei nicht von Details abhängig sein, die es gar nicht benötigt.
Das würde im Fall eines Interfaces Methoden des Interfaces bezeichnen, die der Klient nicht benötigt.
Stattdessen sollten Schnittstellen oder Interfaces möglichst passgenau für den Klienten sein.
Daraus resultieren mehrere Schnittstellen für einen Klienten.
Die Schnittstellen können dabei domänenspezifisch sowie technischspezifisch sein.
Das Ziel ist somit, die Schnittstellen in Nutzergruppen aufzuteilen.

Die letzte Regel des SOLID Prinzips ist das \textit{Dependency Inversion Principle}.
Die Regel beschreibt das Prinzip der Entkopplung.
Die Intuition des Prinzip ist es, dass Abstraktionen nicht von Details abhängen sollten sondern Details von Abstraktionen.
Somit sollten Module höherer Ebenen nicht von Modulen niedriger Ebenen abhängen, stattdessen sollten beide von Abstraktionen abhängen.
Die Lösung dieses Problems ist, dass ein höheres Modul eine Schnittstelle definiert und ein niedrigeres Modul diese implementiert.
Konkret bedeutet dass, dass Klassen höherer Ebenen nicht von Klassen niedrigerer Ebenen abhängig sein sollen, sondern beide Klassen von Interfaces.
Schließlich ist die Abhängigkeit auf eine konkrete Klasse eine starke Kopplung.
Methoden zur Auflösung dieser Kopplung ist die \textit{Dependency Injection} sowie \textit{Dependency Inversion}.
Aus der Anwendung des \textit{Dependency Inversion Principle} resultiert eine Entkopplung der Implementierung.
Die einzelnen Module können somit flexibler miteinander zusammenarbeiten.
Zudem erhält man eine bessere Wiederverwendbarkeit und Schnittstellen werden dadurch zudem klarer und somit wird die Anforderungen deutlicher.

Ein weiteres Programming Principle ist \ac{GRASP}.
\ac{GRASP} stellt Standardlösungen für typische Fragestellungen der Softwarekonzeption bereit.
Innerhalb dieses Softwareentwurfs liegt der Fokus ausschließlich auf den Grundkonzepten \textit{Low Coupling} sowie \textit{High Cohesion}.
Darüber hinaus gibt es sieben weitere Werkzeuge, die jedoch nicht Teil der Anforderungen dieses Software-Entwurfs sind.

\textit{Low Coupling} zielt auf eine geringe Kopplung ab.
Kopplung bezeichnet das Maß für die Abhängigkeit einer Klasse von ihrer Umgebung, wie zum Beispiel anderer Klassen.
Eine geringe Kopplung unterstützt daher eine gute Testbarkeit, leichte Anpassbarkeit, eine bessere Verständlichkeit aufgrund geringeren Kontexts sowie eine erhöhte Wiederverwendbarkeit.
Kopplung im Sourcecode kann

Grundsätzlich bietet eine geringere Kopplung eine bessere Austauschbarkeit des nächsten Befehls.
jedoch ist dabei wichtig, dass eine minimale Kopplung nicht immer die beste Umsetzung bedeutet.
Vielmehr ist eine vernünftige Umsetzung einer geringen Kopplung sinnvoll.
Darüber hinaus finden sich auch weitere Kopplungsarten, wie beispielsweise die Kopplung an Datentypen, Kopplung der Threads, Kopplung durch Formate oder Protokolle sowie Kopplung durch Resourcen.

Ein weiteres Werkzeug ist \textit{High Cohesion}.
\textit{High Cohesion} zielt auf eine hohe Kohäsion ab.
Kohäsion ist das Maß für den inneren Zusammenhalt einer Klasse und beschreibt somit, wie eng Methoden und Attribute auf semantischer Nähe miteinander zusammenarbeiten.
Idealer Code zeichnet sich durch \textit{Low Coupling} in Kombination mit \textit{High Cohesion} aus.
Die Kohäsion kann unter anderem durch Kopplung erhöht werden.
Dazu zählt beispielsweise das Erstellen von Klassen, die eine Eigenschaft der eigentlichen Klasse beinhalten.
Kohäsion ist dabei ein semantisches Maß, somit ist die menschliche Einschätzung darüber entscheident.
Kohäsiver Code bietet zudem den Vorteil zur Analyse.
Durch die Aufteilung der Klassen in Eigenschaften tendiert der Code zur Kürze.
Zudem kann er als Anfangsverdacht für sogenannte \textit{Code Smells} dienen.
Eine ausführlichere Beschreibung zu \textit{Code Smells} ist Teil des Themas \textit{Refactoring}. 

Zu guter Letzt wird das Programming Principle \ac{DRY} betrachtet.
\ac{DRY} folgt dem Prinzip, dass jeder Wissensaspekt nur eine einzige, eindeutige und verbindliche Replikation in einem System besitzt.
Dabei ist eine mechanische Duplikation erlaubt, soweit die Originalquelle klar definiert ist.
\ac{DRY} versucht das Problem zu beheben, dass Quellcode durch mehrfache Wissensaspekte weniger eindeutig wird.
Als Beispiel zählt die Größenangabe einer Oberfläche.
Eine zentrale Angabe der Maße verhindert beim Anpassen der Größe das Missachten einer Stelle im Code, wodurch es bei einer Änderungen zu ungewollten Fehlern, in Form von unterschiedlich großen Oberflächen, kommen kann.
Diese Regel lässt sich sowohl auf Quellcode als auch auf Dokumentationen oder sonstige technische Pläne umsetzen.

Darüber hinaus gibt es mit \ac{KISS}, \ac{YAGNI} sowie dem Conway's Law weitere Programming Principles, die jedoch nicht innerhalb dieses Softwareentwurfs betrachtet werden.

\section{Analyse und Begründung}
In diesen Abschnitt werden die zu betrachtenen Programming Principles in Bezug auf den Softwareentwurf analysiert und Anwendungen entsprechend begründet.

\subsection{SOLID}
Im Folgenden werden die einzelnen Prinzipien des SOLID-Prinzips in Bezug auf den Softwareentwurf betrachet.

\subsubsection*{Single Responsibility Principle}
Ein Beispiel in Bezug auf das \textit{Single Responsibility Principle} ist die Klasse \code{ConsumerGoodToConsumerGoodResourceMapper}.
Die Klasse hat die einzige Aufgabe, Objekte der Klasse \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/3-cip-domain/src/main/java/de/dhbw/cip/domain/ConsumerGoods.java}{\code{ConsumerGood}} zu Objekten der Klasse \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/1-cip-adapters/src/main/java/de/dhbw/cip/adapters/ConsumerGoodsResource.java}{\code{ConsumerGoodResource}} zu mappen und somit für die Interaktion mit der \ac{GUI} zu verwenden.
Das gleiche gilt für die Klasse \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/1-cip-adapters/src/main/java/de/dhbw/cip/adapters/FridgeToFridgeResourceMapper.java}{\code{FridgeToFridgeResourceMapper}} und \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/1-cip-adapters/src/main/java/de/dhbw/cip/adapters/FoodShelfToFoodShelfRessourceMapper.java}{\code{FoodShelfToFoodShelfResourceMapper}}, deren Aufgabe das Mappen eines \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/3-cip-domain/src/main/java/de/dhbw/cip/domain/Fridge.java}{\code{Fridge}}- oder \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/3-cip-domain/src/main/java/de/dhbw/cip/domain/FoodShelf.java}{\code{FoodShelf}}-Objekt zu einer entsprechenden Resource ist.

Das \textit{Single Responsibility Principle} wurde an dieser Stelle eingehalten, da auch die gemappten Klassen für die Kommunikation über die Schnittstellen in der Form nötig sind, wie sie in der Domäne abgebildet sind.

Das \textit{Single Responsibility Principle}-Prinzip wurde hingegen bei den Klassen \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/2-cip-application/src/main/java/de/dhbw/cip/application/ConsumerGoodsManager.java}{\code{ConsumerGoodManager}} sowie \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/2-cip-application/src/main/java/de/dhbw/cip/application/StorageManager.java}{\code{StorageManager}} verletzt. Die Klassen haben neben dem Suchen eines Objekts auch die Aufgabe der Erstellung sowie das Löschen eines Objekts.
In diesem Zusammenhang lässt sich ebenfalls eine Verletzung des \textit{Single Responsibility Principle}-Prinzip bei der Klasse \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/0-cip-plugins/src/main/java/de/dhbw/cip/plugins/rest/ConsumerGoodsGuiController.java}{\code{ConsumerGoodGuiController}} erkennen.
Die Interaktion mit der \ac{GUI} umfasst sowohl das Erstellen, als auch das Ausgeben der verfügbaren Objekte der Klasse \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/3-cip-domain/src/main/java/de/dhbw/cip/domain/ConsumerGoods.java}{\code{ConsumerGood}}.
Gleiches gilt für das Löschen eines Objektes.
Hierzu findet die gesamte Interaktion, die verschiedene Aufgaben enthält, in der Klasse \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/0-cip-plugins/src/main/java/de/dhbw/cip/plugins/rest/ConsumerGoodsGuiController.java}{\code{ConsumerGoodGuiController}} statt.
Die Verletzung des \textit{Single Responsibility Principle}-Prinzip trifft auch auf die Klasse \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/0-cip-plugins/src/main/java/de/dhbw/cip/plugins/rest/StorageGuiController.java}{\code{StorageGuiController}} zu.
Auch hier findet die gesamte Interaktion mit der Schnittstelle, worunter das Ausgeben, Erstellen und Löschen von Objekten des implementierten Interfaces \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/3-cip-domain/src/main/java/de/dhbw/cip/domain/Storage.java}{\code{Storage}} zählt, in der einen Klasse statt.

Die Verletzung des \textit{Single Responsibility Principle} wurde hierbei in Betracht gezogen, die Klassen die zentrale Möglichkeit des Verwalten der Konsumgüter und Lagerplätze übernehmen und hierbei zum einen übergreifend Lösch- oder Anlegeoperationen beim Aktualisieren eines Konsumguts gemacht werden können und zugleich die zentrale Klasse die Möglichkeit der Integration zukünftiger Business-Logik bietet.

\subsubsection*{Open-Closed-Principle}
Das \textit{Open-Closed-Principle} wurde bei den Klassen \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/1-cip-adapters/src/main/java/de/dhbw/cip/adapters/ConsumerGoodsResource.java}{\code{ConsumerGoodResource}}, \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/1-cip-adapters/src/main/java/de/dhbw/cip/adapters/FridgeResource.java}{\code{FridgeResource}} und \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/1-cip-adapters/src/main/java/de/dhbw/cip/adapters/FoodShelfResource.java}{\code{FoodShelfResource}} sowie bei den weiteren Resourcen-Klassen eingehalten.
Das Einfügen neuer Funktionen wie beispielsweise weitere abspeichbare Güter oder weitere Lagermöglichkeiten können umgesetzt werden, indem neue Resourcen-Klassen hinzugefügt werden.
Ein Verändern des bestehenden Codes ist hierzu nicht nötig.

Die Einhaltung des \textit{Open-Closed-Principle} ist an dieser Stelle dadurch gegeben, da die Resourcen-Klassen Klassen aus der Domäne abbilden und somit eine Erweiterung in der Domäne eben zu einer Erweiterung durch Hinzufügen einer neuen Resourcen-Klasse führt. 

Eine Verletzung des \textit{Open-Closed-Principle} stellen die Klassen \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/0-cip-plugins/src/main/java/de/dhbw/cip/plugins/rest/ConsumerGoodsGuiController.java}{\code{ConsumerGoodGuiController}} und \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/0-cip-plugins/src/main/java/de/dhbw/cip/plugins/rest/StorageGuiController.java}{\code{StorageGuiController}} dar.
Eine Erweiterung der Anwendung um ein weiteres zu verwaltendes Gut hätte hierbei zur Folge, dass die Einbindung eines neuen Guts zu einer Veränderung der Schnittstelle für die \ac{GUI} führt, um das neue Gut in der \ac{GUI} zu repräsentieren.

Das \textit{Open-Closed-Principle} ist an dieser Stelle verletzt worden, weil eine Abweichung vom \ac{REST}-Paradigma vorgenommen wurde und stattdessen Home-Made-Messaging umgesetzt wurde.
Daraus resultiert diese Verletzung und führt dazu, dass das \ac{GUI}-Plugin aktuell sehr stark an die Schnittstelle angepasst ist.

\subsubsection*{Liskov Substitution Principle}
%Die Analyse des Liskov Substitution Principles ist nur in einem älteren Stand des Softwareentwurfs zu analysieren, da zum aktuellen Stand keine Vererbung implementiert ist.
Es ist eine Vererbung der Superklasse \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/4-cip-abstractioncode/src/main/java/de/dhbw/cip/abstractioncode/UnitOfMeasure.java}{\code{UnitOfMeasure}} und den Subklassen \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/4-cip-abstractioncode/src/main/java/de/dhbw/cip/abstractioncode/Volume.java}{\code{Volume}}, \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/4-cip-abstractioncode/src/main/java/de/dhbw/cip/abstractioncode/Weight.java}{\code{Weight}} und \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/4-cip-abstractioncode/src/main/java/de/dhbw/cip/abstractioncode/Quantity.java}{\code{Quantity}} implementiert.
Bei \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/4-cip-abstractioncode/src/main/java/de/dhbw/cip/abstractioncode/UnitOfMeasure.java}{\code{UnitOfMeasure}} handelt es sich um eine abstrakte Klasse.
Die Subklassen überschreiben jedoch keine Funktionalität der Superklasse, weshalb das \textit{Liskov Substitution Principle} an dieser Stelle eingehalten wird.

Das Gleiche gilt für die Implementierung der Vererbung der Superklasse \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/3-cip-domain/src/main/java/de/dhbw/cip/domain/Storage.java}{\code{Storage}} und den Subklassen \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/3-cip-domain/src/main/java/de/dhbw/cip/domain/Fridge.java}{\code{Fridge}} und \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/3-cip-domain/src/main/java/de/dhbw/cip/domain/FoodShelf.java}{\code{FoodShelf}}.
Auch in diesem Fall ist die Klasse \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/3-cip-domain/src/main/java/de/dhbw/cip/domain/Storage.java}{\code{Storage}} abstrakt und die Subklassen überschreiben keine Funktionalität der Superklasse, wodurch das \textit{Liskov Substitution Principle} eingehalten wird.

Das \textit{Liskov Substitution Principle} wurde hierbei eingehalten, weil sich die Vererbung stark an der Nutzung von Interfaces orientiert.
Diese sind auch an dieser Stelle für die Superklassen \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/4-cip-abstractioncode/src/main/java/de/dhbw/cip/abstractioncode/UnitOfMeasure.java}{\code{UnitOfMeasure}} und \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/3-cip-domain/src/main/java/de/dhbw/cip/domain/Storage.java}{\code{Storage}} vorgesehen gewesen, allerdings führt das bei der Persistierung durch Hibernate zu Fehlern, da Hibernate die Referenz auf den direkten Typen benötigt und dieser bei Interfaces für Hibernate nicht ermittelbar ist.

\subsubsection*{Interface Segregation Principle}
Ein Positivbeispiel der Umsetzung des \textit{Interface Segregation Principle} zeigt sich in den Interfaces \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/3-cip-domain/src/main/java/de/dhbw/cip/domain/FridgeRepository.java}{\code{FridgeRepository}} und \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/3-cip-domain/src/main/java/de/dhbw/cip/domain/FoodShelfRepository.java}{\code{FoodShelfRepositoy}}.

Hierbei wurde in Hinblick auf das \textit{Interface Segregation Principle} bedacht, dass unterschiedliche Lagermöglichkeiten unterschiedliche Eigenschaften und Funktionalitäten bieten können, die in einem gemeinsamen Repository-Interface nicht abbildbar wären.
Diese Entscheidung ist auch im Hinblick der Erweiterbarkeit in Form zukünftiger weiterer Lagermöglichkeiten konzipiert.

Die Interfaces können jedoch zugleich als Negativbeispiel betrachtet werden.
Die Repository-Interfaces übernehmen sowohl Lesezugriff als auch die Möglichkeit der Übergabe zur späteren Persistierung.
Nach dem \textit{Interface Segregation Principle} wäre eine Trennung nach Leseoperationen und Schreiboperationen in separate Interfaces geeigneter.
Im Hinblick auf mögliche Erweiterungen könnte es sonst zu Problemen oder Umständen bei der Implementierung einer Berechtigungskontrolle auf die verwalteten Ressourcen kommen.
Diesen Negativpunkt betrifft ebenfalls das Interface \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/3-cip-domain/src/main/java/de/dhbw/cip/domain/ConsumerGoodsRepository.java}{\code{ConsumerGoodRepository}}.

\subsubsection*{Dependency Inversion Principle}
Die Einhaltung des \textit{Dependency Inversion Principle} war bei den Klassen \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/3-cip-domain/src/main/java/de/dhbw/cip/domain/ConsumerGoods.java}{\code{ConsumerGood}} sowie \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/3-cip-domain/src/main/java/de/dhbw/cip/domain/Food.java}{\code{Food}} und dem Interface \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/3-cip-domain/src/main/java/de/dhbw/cip/domain/StorableGoods.java}{\code{StorableGood}} geplant.
Die Klasse \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/3-cip-domain/src/main/java/de/dhbw/cip/domain/ConsumerGoods.java}{\code{ConsumerGood}} referenziert dabei auf ein Objekt des Typs \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/3-cip-domain/src/main/java/de/dhbw/cip/domain/StorableGoods.java}{\code{StorableGood}}. 
Das hätte zur Folge, dass unter Anwendung der Dependency Injection eine Erweiterung weiterer lagerbarer Objekte neben Essen möglich ist, ohne die Klasse \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/3-cip-domain/src/main/java/de/dhbw/cip/domain/ConsumerGoods.java}{\code{ConsumerGood}} hierzu anpassen zu müssen. 
Die Klasse \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/3-cip-domain/src/main/java/de/dhbw/cip/domain/ConsumerGoods.java}{\code{ConsumerGood}} referenziert dabei auf ein Objekt des Typs \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/3-cip-domain/src/main/java/de/dhbw/cip/domain/StorableGoods.java}{\code{StorableGood}}.

Gleiches gilt für die Umsetzung der Superklassen \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/3-cip-domain/src/main/java/de/dhbw/cip/domain/Storage.java}{\code{Storage}} und \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/4-cip-abstractioncode/src/main/java/de/dhbw/cip/abstractioncode/UnitOfMeasure.java}{\code{UnitOfMeasure}} als Interfaces in Bezug auf die Klasse \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/3-cip-domain/src/main/java/de/dhbw/cip/domain/ConsumerGoods.java}{\code{ConsumerGood}}.
Auch hierbei könnten neue Lagermöglichkeiten oder Maßeinheiten hinzugefügt werden, ohne dass die Klasse \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/3-cip-domain/src/main/java/de/dhbw/cip/domain/ConsumerGoods.java}{\code{ConsumerGood}} dafür angepasst werden muss.

Es ist zu erwähnen, dass es sich in beiden Betrachtungen um Planungen handelt, deren resultierender Vorteil beschrieben wurde.
Aufgrund der Tatsache, dass die Persistierung mit Hibernate in den Domain-Klassen umgesetzt wurde, kommt es hierbei zu dem Problem, dass Hibernate über den Typen des Interfaces die Referenz nicht auflösen kann.
Daher ist zum aktuellen Zeitpunkt noch das referenzierte Gut vom Typ \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/3-cip-domain/src/main/java/de/dhbw/cip/domain/Food.java}{\code{Food}} sowie \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/3-cip-domain/src/main/java/de/dhbw/cip/domain/Storage.java}{\code{Storage}} und \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/4-cip-abstractioncode/src/main/java/de/dhbw/cip/abstractioncode/UnitOfMeasure.java}{\code{UnitOfMeasure}} als Superklassen implementiert.

Darüber hinaus sind die Interfaces \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/3-cip-domain/src/main/java/de/dhbw/cip/domain/ConsumerGoodsRepository.java}{\code{ConsumerGoodRepository}}, \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/3-cip-domain/src/main/java/de/dhbw/cip/domain/FridgeRepository.java}{\code{FridgeRepository}} und \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/3-cip-domain/src/main/java/de/dhbw/cip/domain/FoodShelfRepository.java}{\code{FoodShelfRepository}} ein weiteres und implementiertes Beispiel des \textit{Dependency Inversion Principle}.
Die Interfaces definieren alle nötigen Methoden und die Services \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/2-cip-application/src/main/java/de/dhbw/cip/application/ConsumerGoodsManager.java}{\code{ConsumerGoodManager}} und \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/2-cip-application/src/main/java/de/dhbw/cip/application/StorageManager.java}{\code{StorageManager}} haben zur Laufzeit eine Abhängigkeit auf ein Objekt, welches das entsprechende Interface implementiert hat.
Durch die Einhaltung des \textit{Dependency Inversion Principle} resultiert der Vorteil, dass die tatsächlichen Objekte problemlos ausgetauscht werden können und das Einsetzen von Mocks zum Testen vereinfacht wird, indem die entsprechenden Methoden des Interfaces gemockt werden.

Eine Verletzung des \textit{Dependency Inversion Principle} ist in den Mapper Klassen der Ressourcen-Mapper-Klassen zu finden. Die Verwendung der Klassen \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/1-cip-adapters/src/main/java/de/dhbw/cip/adapters/ConsumerGoodsToConsumerGoodsResourceMapper.java}{\code{ConsumerGoodToConsumerGoodResourceMapper}}, \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/1-cip-adapters/src/main/java/de/dhbw/cip/adapters/FridgeToFridgeResourceMapper.java}{\code{FridgeToFridgeResourceMapper}} sowie \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/1-cip-adapters/src/main/java/de/dhbw/cip/adapters/FoodShelfToFoodShelfRessourceMapper.java}{\code{FoodShelfToFoodShelfResourceMapper}} hängt direkt von den jeweiligen Instanzen der Mapper-Klassen ab.
Eine Lösung zum Beheben der Verletzung wäre das nutzen eines Interfaces, das die Resourcen-Mapper-Klassen implementieren.
Dadurch wäre eine stärkere Entkopplung möglich.
Dennoch wurde hierbei die Verletzung des \textit{Dependency Inversion Principle} zum besseren Verständnis und einer besseren Lesbarkeit durch eine klarere Zuordnung innerhalb des Programmcodes gemacht.

\subsection{\ac{GRASP}}

\subsubsection*{Geringe Kopplung}
Eine geringe Kopplung findet sich zwischen der \ac{GUI} und der Applikationsschicht der Anwendung.
Die Interaktion findet über die Klasse \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/0-cip-plugins/src/main/java/de/dhbw/cip/plugins/rest/ConsumerGoodsGuiController.java}{\code{ConsumerGoodGuiController}} und \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/0-cip-plugins/src/main/java/de/dhbw/cip/plugins/rest/StorageGuiController.java}{\code{StorageGuiController}} statt.
Beide Klassen dienen als \ac{HTTP}-Interface.
Durch die Kommunikation über \ac{HTTP} kennen sich die Anwendung und die \ac{GUI} nicht und sind somit entkoppelt.

Hierbei wurde auf eine geringe Kopplung geachtet, da \ac{GUI}-Plugins und die dafür verwendete Technologie tendenziell zu kürzeren Lebenszyklen neigen.
Durch die geringe Kopplung ist ein Austausch durch eine andere Technologie für die grafische Oberfläche, die eine Kommunikation über das \ac{HTTP}-Protokoll ermöglicht, umsetzbar ohne Änderungen an dem Service vornehmen zu müssen.
Zudem ist dadurch eine Kommunikation mit weiteren Plugins über das \ac{HTTP}-Protokoll möglich.

Eine geringe Kopplung wurde bei der Implementierung ebenfalls erzielt, indem die Repository-Klassen \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/3-cip-domain/src/main/java/de/dhbw/cip/domain/ConsumerGoodsRepository.java}{\code{ConsumerGoodRepository}}, \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/3-cip-domain/src/main/java/de/dhbw/cip/domain/FridgeRepository.java}{\code{FridgeRepository}} und \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/3-cip-domain/src/main/java/de/dhbw/cip/domain/FoodShelfRepository.java}{\code{FoodShelfRepository}} bei der Rückgabe der instanziierten Objekte diese nicht als Liste vom Typ \textit{List} zurückgeben sondern als \textit{Iterable}.
Hierdurch wird die Kopplung, welche die Repository-Interfaces sonst durch den Rückgabetyp erzeugen, reduziert.
Einzelne Objekte werden zudem als \textit{Optional} zurückgegeben, was vor allem entkoppelt, da keine Regelungen getroffen werden müssen, falls kein den übergebenen Kriterien entsprechendes Objekt vorhanden ist, das zurückgegeben werden kann.

Es wurde hierbei auf eine geringe Kopplung geachtet, da es die Möglichkeit bietet, in Zukunft fortschrittlichere konkrete Implementierung des Typs \textit{Iterable} zu verwenden und nicht an einen konkreten Typ, der gegenwärtig aktuell ist, gebunden zu sein.

Eine stärkere Kopplung ist in den Serviceklassen \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/2-cip-application/src/main/java/de/dhbw/cip/application/ConsumerGoodsManager.java}{\code{ConsumerGoodManager}} und \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/2-cip-application/src/main/java/de/dhbw/cip/application/StorageManager.java}{\code{StorageManager}} zu finden.
Zum Löschen, Persistieren oder der Rückgabe initialisierter Objekte der Klassen \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/3-cip-domain/src/main/java/de/dhbw/cip/domain/ConsumerGoods.java}{\code{ConsumerGood}}, \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/3-cip-domain/src/main/java/de/dhbw/cip/domain/Fridge.java}{\code{Fridge}} oder \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/3-cip-domain/src/main/java/de/dhbw/cip/domain/FoodShelf.java}{\code{FoodShelf}} werden ausschließlich die in den entsprechenden Repository-Interfaces definierten Klassen verwendet.
Für den Zugriff auf eine Referenz des jeweiligen implementierten Repository-Types wird durch eine \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/2-cip-application/src/main/java/de/dhbw/cip/application/ConsumerGoodsManager.java#L18}{\code{Dependency Injection}} in \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/2-cip-application/src/main/java/de/dhbw/cip/application/ConsumerGoodsManager.java}{\code{ConsumerGoodManager}} sowie in \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/2-cip-application/src/main/java/de/dhbw/cip/application/StorageManager.java}{\code{StorageManager}} ermöglicht.
Somit ist hierbei keine direkte Kopplung an eine konkrete Implementierung eines Repository-Objekts vorhanden.

Es wurde hierbei auf eine ebenfalls geringe, wenn auch stärkere als zuvor, Kopplung geachtet, da somit ein Austausch des konkreten Typs des entsprechenden Repositories möglich ist.
Das ist gerade in Hinblick auf den Austausch der Technologie zur Persistierung relevant und entkoppelt die Business-Logik von der konkreten Umsetzung der Persistierung.

Ein Beispiel mit einer starken Kopplung ist der statische Methodenaufruf \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/3-cip-domain/src/main/java/de/dhbw/cip/domain/DateValidator.java#L10}{\code{validate()}} der Klasse \code{DateValidator}.
Auch in diesem Fall entsteht durch den statischen Methodenaufruf eine starke Kopplung an die Klasse \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/3-cip-domain/src/main/java/de/dhbw/cip/domain/DateValidator.java}{\code{DateValidator}}.

Diese starke Kopplung wurde gemacht, da davon auszugehen ist, dass sich die Validierungen an Grundlagen und Rechtmäßigkeiten innerhalb der Domäne orientieren und somit der Eintritt einer Änderung als eher weniger wahrscheinlich erscheint.

\subsubsection*{Hohe Kohäsion}
Ein Beispiel für eine hohe Kohäsion ist in der Klasse \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/3-cip-domain/src/main/java/de/dhbw/cip/domain/ConsumerGoods.java}{\code{ConsumerGood}} zu sehen.
Die Bestandteile eines Konsumguts sind das Lebensmittel und die dazugehörige Menge samt Maßeinheit.
Das Lebensmittel wird dazu in der Klasse \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/3-cip-domain/src/main/java/de/dhbw/cip/domain/Food.java}{\code{Food}} verwaltet, während die Menge in einem Objekt des implementierten Interface-Typs \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/4-cip-abstractioncode/src/main/java/de/dhbw/cip/abstractioncode/UnitOfMeasure.java}{\code{UnitOfMeasure}} verwaltet ist.
Die Klasse \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/3-cip-domain/src/main/java/de/dhbw/cip/domain/Food.java}{\code{Food}} hat als Attribut eine Instanz der Klasse \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/3-cip-domain/src/main/java/de/dhbw/cip/domain/BestBeforeDate.java}{\code{BestBeforeDate}} zur Repräsentation des Mindesthaltbarkeitsdatums.
In der Klasse \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/3-cip-domain/src/main/java/de/dhbw/cip/domain/BestBeforeDate.java}{\code{BestBeforeDate}} werden auch datumsspezifische Operationen wie zum Beispiel die Datumsüberprüfung mithilfe des \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/3-cip-domain/src/main/java/de/dhbw/cip/domain/DateValidator.java}{\code{DateValidators}} übernommen.
Das Objekt der Superklasse \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/4-cip-abstractioncode/src/main/java/de/dhbw/cip/abstractioncode/UnitOfMeasure.java}{\code{UnitOfMeasure}} repräsentiert die Menge in Form der spezialisierte Klassen \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/4-cip-abstractioncode/src/main/java/de/dhbw/cip/abstractioncode/Weight.java}{\code{Weight}}, \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/4-cip-abstractioncode/src/main/java/de/dhbw/cip/abstractioncode/Volume.java}{\code{Volume}} oder \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/4-cip-abstractioncode/src/main/java/de/dhbw/cip/abstractioncode/Quantity.java}{\code{Quantity}}.
Der Wert der Menge wird in den Klassen durch das Attribut vom Typ \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/4-cip-abstractioncode/src/main/java/de/dhbw/cip/abstractioncode/Value.java}{\code{Value}} verwaltet.

Das Ziel durch Schaffung einer hohen Kohäsion ist hierdurch, dass die jeweiligen Bestandteile des \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/3-cip-domain/src/main/java/de/dhbw/cip/domain/ConsumerGoods.java}{\code{ConsumerGood}} in einzelnen Klassen verwaltet werden, dadurch teilt sich der Code auf die entsprechenden Schwerpunkte auf und wird, gerade in Bezug auf Übergabe- und Rückgabeparameter, lesbarer.

Ein weiteres Beispiel für hohe Kohäsion ist die Klasse \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/3-cip-domain/src/main/java/de/dhbw/cip/domain/BestBeforeDate.java}{\code{BestBeforeDate}}.
Das Mindesthaltbarkeitsdatum wird durch die Variablen des Typs \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/3-cip-domain/src/main/java/de/dhbw/cip/domain/DayOfYear.java}{\code{DayOfYear}} und \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/4-cip-abstractioncode/src/main/java/de/dhbw/cip/abstractioncode/Year.java}{\code{Year}} repräsentiert.
\href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/3-cip-domain/src/main/java/de/dhbw/cip/domain/DayOfYear.java}{\code{DayOfYear}} verwaltet das Datum eines Jahres durch die Attribute vom Typ \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/4-cip-abstractioncode/src/main/java/de/dhbw/cip/abstractioncode/Day.java}{\code{Day}} und \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/4-cip-abstractioncode/src/main/java/de/dhbw/cip/abstractioncode/Month.java}{\code{Month}}.

Der Vorteil durch die Umsetzung der hohen Kohäsion ist auch hierbei, dass die Lesbarkeit bei geforderten Übergabe- und Rückgabeparametern über die genaue Typen-Bezeichnung deutlich lesbarer und verständlicher ist als ein primitiver Datentyp.
Darüber hinaus ist nicht die Klasse \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/3-cip-domain/src/main/java/de/dhbw/cip/domain/BestBeforeDate.java}{\code{BestBeforeDate}} für eine genaue Spezifizierung oder Anpassung der einzelnen Attribute verantwortlich sondern die jeweiligen spezifischen Klassen.

\subsection{\ac{DRY}}
Das verwendete Framework Spring Boot bietet den Ansatz \textit{Convention over Configuration}.
Dadurch müssen bei Einhaltung von Konventionen keine zusätzlichen Konfigurationen durchgeführt werden.
Ein anschauliches Beispiel des \textit{Convention over Configuration}-Ansatzes ist das Erzeugen von Tabellennamen entsprechend der Bezeichnung der Entität.
Hierzu muss die Tabellenbezeichnung nicht zusätzlich konfiguriert werden sondern es wird direkt die Bezeichnung der Entitätsklasse verwendet.
Wie im Beispiel \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/3-cip-domain/src/main/java/de/dhbw/cip/domain/ConsumerGoods.java}{\code{ConsumerGood}} zu erkennen, reicht die Deklarierung \textit{@Table} aus.

Das gleiche betrifft die Bezeichnung der Spalten entsprechend der Attributbezeichnung.
Ebenfalls im Beispiel \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/3-cip-domain/src/main/java/de/dhbw/cip/domain/ConsumerGoods.java}{\code{ConsumerGood}} zu erkennen, reicht die Deklarierung \textit{@Column} aus.

Der Vorteil ist, dass bei dieser Einhaltung des \ac{DRY}-Prinzips der Zusammenhang zwischen dem Programmcode und den Tabellen zur Persistierung für den Entwickler leicht zu erkennen ist und Umbennenungen der Klassen direkt zu einer Anpassung der Tabellenbezeichnung sorgt und somit Inkonsistenzen vermieden werden können.

Eine Nichteinhaltung des \ac{DRY}-Prinzip findet sich in der Resourcen-Klassen \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/1-cip-adapters/src/main/java/de/dhbw/cip/adapters/ConsumerGoodsResource.java}{\code{ConsumerGoodResource}}, \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/1-cip-adapters/src/main/java/de/dhbw/cip/adapters/FridgeResource.java}{\code{FridgeResource}}, \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/1-cip-adapters/src/main/java/de/dhbw/cip/adapters/FoodShelfResource.java}{\code{FoodShelfResource}}, \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/1-cip-adapters/src/main/java/de/dhbw/cip/adapters/FoodResource.java}{\code{FoodResource}} und \href{https://github.com/lucasmerkel/dhbw-advancedswe-programmentwurf/blob/5764d7da4cfd0562ed8e96128e92f85c30b7309d/swe_programmentwurf/consumergoods-inventory-planner/1-cip-adapters/src/main/java/de/dhbw/cip/adapters/BestBeforeDateResource.java}{\code{BestBeforeDateResource}} vor.
Die Klassen dienen der Repräsentation der gleichnamigen Entitäten für die Kommunikation mit äußeren Anwendungen wie beispielsweise der \ac{GUI}.
Dementsprechend sind sowohl Variablen als auch Methoden dupliziert.
Dadurch ist das \ac{DRY}-Prinzip verletzt und hat den Nachteil, dass eine Anpassung der Domänen dazu führt, dass die entsprechende Ressourcen-Klasse ebenfalls angepasst werden müsste.

Das \ac{DRY}-Prinzip wurde hierbei bewusst verletzt, weil eine Duplizierung zur Trennung des Domänencodes im Inneren zu einer Repräsentation Interaktion mit äußeren Plugins entsprechend der \textit{Clean Architecture} gewollt ist.
Hierbei ist anzumerken, dass Domänen in der \textit{Domain}-Schicht entsprechend der \textit{Clean Architecture} eher seltener verändert werden sollten.
Dennoch würde müsste die Änderung auch in den Ressourcen-Klassen berücksichtigt werden und kann somit zu einem Fehlerrisiko durch Nichtberücksichtigung führen.
